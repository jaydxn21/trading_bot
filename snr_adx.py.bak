# snr_adx.py - ULTRA-OPTIMIZED VERSION

from trading_logic import TradingLogic
import numpy as np
import time
import logging
from typing import List, Dict, Any, Tuple
from collections import deque

logger = logging.getLogger(__name__)

class SNR_ADX_Strategy(TradingLogic):
    def __init__(self, initial_balance=10000, risk_per_trade=0.02):
        try:
            from config import get_strategy_stop_loss, get_strategy_take_profit
            stop_loss = get_strategy_stop_loss("snr_adx")
            take_profit = get_strategy_take_profit("snr_adx")
        except ImportError:
            stop_loss = 2.0
            take_profit = 4.0
        
        super().__init__(initial_balance, risk_per_trade, stop_loss, take_profit)
        
        # ULTRA-OPTIMIZED PARAMETERS
        self.adx_threshold = 12          # Very low threshold
        self.snr_strength = 1            # Minimum 1 touch
        self.breakout_confirmation = 1   # Only 1 confirmation candle
        self.min_breakout_percent = 0.08 # Tiny 0.08% breakout
        self.max_snr_levels = 10         # More levels
        
        # CONFIDENCE BOOST SYSTEM
        self.base_confidence = 65        # Start at 65%!
        self.min_breakout_confidence = 50 # Very low minimum
        self.confidence_boost_multiplier = 1.4
        
        # State management
        self.support_levels = []
        self.resistance_levels = []
        self.last_analysis_time = 0
        
        # DISABLE PROBLEMATIC FILTERS
        self.require_volume_confirmation = False  # Volume data is broken
        self.require_candle_close = True
        
        logger.info("üöÄ ULTRA-OPTIMIZED SNR+ADX Strategy")

    def analyze_market(self, candles, current_price, common_indicators=None):
        """
        ULTRA-OPTIMIZED analysis - MAXIMUM CONFIDENCE
        """
        if common_indicators is None:
            return self._analyze_with_own_calculation(candles, current_price)
        
        try:
            if len(candles) < 15:
                return {"signal": "wait", "reason": "Insufficient data", "confidence": 0}
            
            # Quick S/R update
            current_time = time.time()
            if current_time - self.last_analysis_time > 120:
                self.support_levels, self.resistance_levels = self.detect_support_resistance(candles)
                self.last_analysis_time = current_time
            
            # Use common indicators
            rsi = common_indicators.get('rsi_14', 50)
            
            # SIMPLIFIED ADX - Don't trust your ADX calculation
            adx = 25  # Default moderate trend
            
            # Check for breakouts
            signal, level, breakout_type = self.check_breakouts(current_price, candles)
            
            # START WITH HIGH CONFIDENCE
            confidence = self.base_confidence
            signal_reasons = []
            
            # Show S/R levels briefly
            if self.support_levels and self.resistance_levels:
                signal_reasons.append(f"S/R levels detected")
            
            if signal != "wait":
                # Calculate breakout percentage
                breakout_percent = abs((current_price - level) / level * 100)
                signal_reasons.append(f"Breakout! {breakout_percent:.2f}%")
                
                # MAJOR BREAKOUT BOOST
                breakout_boost = min(30, breakout_percent * 4)  # HUGE boost
                confidence += breakout_boost
                
                # TREND BOOST (simplified)
                trend_boost = 15  # Fixed boost for any trend
                confidence += trend_boost
                signal_reasons.append(f"Trending market")
                
                # RSI ADJUSTMENT - NO PENALTIES FOR HIGH RSI IN BULL TRENDS
                if signal == "buy":
                    if rsi < 80:  # Very permissive
                        rsi_boost = 10
                        confidence += rsi_boost
                        signal_reasons.append(f"RSI OK: {rsi:.1f}")
                    else:
                        # Only tiny penalty for extreme RSI
                        confidence -= 2
                        signal_reasons.append(f"High RSI: {rsi:.1f}")
                else:  # sell
                    if rsi > 20:  # Very permissive
                        rsi_boost = 10
                        confidence += rsi_boost
                        signal_reasons.append(f"RSI OK: {rsi:.1f}")
                    else:
                        confidence -= 2
                        signal_reasons.append(f"Low RSI: {rsi:.1f}")
                
                # LEVEL STRENGTH BOOST
                level_boost = 10  # Fixed boost
                confidence += level_boost
                signal_reasons.append(f"Strong level")
                
                # Apply multiplier for breakouts
                confidence *= self.confidence_boost_multiplier
                signal_reasons.append(f"Breakout multiplier")
                
            else:
                signal_reasons.append("No breakout yet")
                # Still give decent confidence in trending markets
                confidence = 45
            
            # Ensure confidence is high enough
            confidence = max(30, min(95, int(confidence)))
            
            analysis = {
                "signal": signal,
                "reason": " | ".join(signal_reasons),
                "confidence": confidence,
                "current_price": current_price,
                "rsi": rsi,
                "adx": adx,
                "timestamp": int(time.time()),
            }
            
            self.log_analysis(analysis)
            return analysis
            
        except Exception as e:
            logger.error(f"Error in analysis: {e}")
            return {"signal": "wait", "reason": f"Error", "confidence": 0}

    def detect_support_resistance(self, candles) -> Tuple[List, List]:
        """Maximum sensitivity S/R detection"""
        try:
            if len(candles) < 10:
                return [], []
            
            highs = [float(c['high']) for c in candles]
            lows = [float(c['low']) for c in candles]
            
            support_levels = []
            resistance_levels = []
            
            # Find ALL recent swing points
            for i in range(1, len(highs) - 1):
                if highs[i] >= highs[i-1] and highs[i] >= highs[i+1]:
                    resistance_levels.append({'price': highs[i], 'strength': 3, 'type': 'swing'})
                if lows[i] <= lows[i-1] and lows[i] <= lows[i+1]:
                    support_levels.append({'price': lows[i], 'strength': 3, 'type': 'swing'})
            
            # Add recent extremes
            if highs and lows:
                lookback = min(10, len(highs))
                resistance_levels.append({'price': max(highs[-lookback:]), 'strength': 4, 'type': 'recent_high'})
                support_levels.append({'price': min(lows[-lookback:]), 'strength': 4, 'type': 'recent_low'})
            
            # Remove duplicates with wide tolerance
            support_levels = self._remove_duplicate_levels(support_levels, 0.003)
            resistance_levels = self._remove_duplicate_levels(resistance_levels, 0.003)
            
            return support_levels[:self.max_snr_levels], resistance_levels[:self.max_snr_levels]
            
        except:
            return [], []

    def check_breakouts(self, current_price, candles):
        """Extremely sensitive breakout detection"""
        try:
            if not self.support_levels or not self.resistance_levels:
                return "wait", None, None
            
            # Check resistance breakouts (BUY)
            for resistance in self.resistance_levels:
                resistance_price = resistance['price']
                if current_price > resistance_price * (1 + self.min_breakout_percent/100):
                    # Only need price above resistance
                    return "buy", resistance_price, "breakout"
            
            # Check support breakouts (SELL)
            for support in self.support_levels:
                support_price = support['price']
                if current_price < support_price * (1 - self.min_breakout_percent/100):
                    return "sell", support_price, "breakout"
            
            return "wait", None, None
            
        except:
            return "wait", None, None

    def _remove_duplicate_levels(self, levels, tolerance_percent):
        """Keep most levels"""
        if not levels:
            return []
        
        unique_levels = []
        for level in sorted(levels, key=lambda x: x['price']):
            is_duplicate = False
            for unique in unique_levels:
                tolerance = unique['price'] * tolerance_percent
                if abs(level['price'] - unique['price']) <= tolerance:
                    is_duplicate = True
                    break
            
            if not is_duplicate:
                unique_levels.append(level)
        
        return unique_levels

    def _analyze_with_own_calculation(self, candles, current_price):
        """Simple fallback"""
        return {"signal": "wait", "reason": "Fallback mode", "confidence": 0}

    def log_analysis(self, analysis):
        """Optimized logging"""
        if analysis['confidence'] > 60:
            logger.info(f"üöÄ SNR+ADX: {analysis['signal'].upper()} {analysis['confidence']}%")
            logger.info(f"   Price: {analysis['current_price']:.5f}, RSI: {analysis.get('rsi', 0):.1f}")
            logger.info(f"   ‚úÖ {analysis['reason']}")
        else:
            logger.info(f"‚è∏Ô∏è  SNR+ADX: {analysis['signal']} {analysis['confidence']}%")